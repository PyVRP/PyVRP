from typing import Iterator, overload

import pyvrp
from pyvrp._pyvrp import (
    CostEvaluator,
    DurationSegment,
    LoadSegment,
    ProblemData,
    RandomNumberGenerator,
)

class OperatorStatistics:
    num_evaluations: int
    num_applications: int

class UnaryOperator:
    def __init__(self, data: ProblemData) -> None: ...
    @property
    def statistics(self) -> OperatorStatistics: ...
    def evaluate(self, U: Node, cost_evaluator: CostEvaluator) -> int: ...
    def apply(self, U: Node) -> None: ...
    @staticmethod
    def supports(data: ProblemData) -> bool: ...

class BinaryOperator:
    def __init__(self, data: ProblemData) -> None: ...
    @property
    def statistics(self) -> OperatorStatistics: ...
    def evaluate(
        self, U: Node, V: Node, cost_evaluator: CostEvaluator
    ) -> int: ...
    def apply(self, U: Node, V: Node) -> None: ...
    @staticmethod
    def supports(data: ProblemData) -> bool: ...

class Exchange10(BinaryOperator): ...
class Exchange11(BinaryOperator): ...
class Exchange20(BinaryOperator): ...
class Exchange21(BinaryOperator): ...
class Exchange22(BinaryOperator): ...
class Exchange30(BinaryOperator): ...
class Exchange31(BinaryOperator): ...
class Exchange32(BinaryOperator): ...
class Exchange33(BinaryOperator): ...
class RelocateWithDepot(BinaryOperator): ...
class SwapTails(BinaryOperator): ...

class SearchSpace:
    def __init__(
        self,
        data: ProblemData,
        neighbours: list[list[int]],
    ) -> None: ...
    @property
    def neighbours(self) -> list[list[int]]: ...
    @neighbours.setter
    def neighbours(self, neighbours: list[list[int]]) -> None: ...
    def neighbours_of(self, client: int) -> list[int]: ...
    def is_promising(self, client: int) -> bool: ...
    @overload
    def mark_promising(self, client: int) -> None: ...
    @overload
    def mark_promising(self, node: Node) -> None: ...
    def mark_all_promising(self) -> None: ...
    def unmark_all_promising(self) -> None: ...
    def client_order(self) -> list[int]: ...
    def veh_type_order(self) -> list[tuple[int, int]]: ...
    def shuffle(self, rng: RandomNumberGenerator) -> None: ...

class PerturbationParams:
    min_perturbations: int
    max_perturbations: int
    def __init__(
        self,
        min_perturbations: int = 1,
        max_perturbations: int = 25,
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...

class PerturbationManager:
    def __init__(
        self,
        params: PerturbationParams = ...,
    ) -> None: ...
    def num_perturbations(self) -> int: ...
    def shuffle(self, rng: RandomNumberGenerator) -> None: ...
    def perturb(
        self,
        solution: Solution,
        search_space: SearchSpace,
        cost_evaluator: CostEvaluator,
    ) -> None: ...

class LocalSearchStatistics:
    num_moves: int
    num_improving: int
    num_updates: int

class LocalSearch:
    def __init__(
        self,
        data: ProblemData,
        neighbours: list[list[int]],
        perturbation_manager: PerturbationManager = ...,
    ) -> None: ...
    def add_operator(self, op: UnaryOperator | BinaryOperator) -> None: ...
    @property
    def neighbours(self) -> list[list[int]]: ...
    @neighbours.setter
    def neighbours(self, neighbours: list[list[int]]) -> None: ...
    @property
    def unary_operators(self) -> list[UnaryOperator]: ...
    @property
    def binary_operators(self) -> list[BinaryOperator]: ...
    @property
    @property
    def statistics(self) -> LocalSearchStatistics: ...
    def __call__(
        self,
        solution: pyvrp.Solution,
        cost_evaluator: CostEvaluator,
        exhaustive: bool = False,
    ) -> pyvrp.Solution: ...
    def shuffle(self, rng: RandomNumberGenerator) -> None: ...

class Solution:
    nodes: list[Node]
    routes: list[Route]
    def __init__(self, data: ProblemData) -> None: ...
    def load(self, solution: pyvrp.Solution) -> None: ...
    def unload(self) -> pyvrp.Solution: ...
    def insert(
        self,
        node: Node,
        search_space: SearchSpace,
        cost_evaluator: CostEvaluator,
        required: bool,
    ) -> bool: ...

class Route:
    def __init__(self, data: ProblemData, vehicle_type: int) -> None: ...
    @property
    def vehicle_type(self) -> int: ...
    def num_clients(self) -> int: ...
    def num_depots(self) -> int: ...
    def num_trips(self) -> int: ...
    def max_trips(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __delitem__(self, idx: int) -> None: ...
    def __getitem__(self, idx: int) -> Node: ...
    def __iter__(self) -> Iterator[Node]: ...
    def __len__(self) -> int: ...
    def is_feasible(self) -> bool: ...
    def has_excess_load(self) -> bool: ...
    def has_excess_distance(self) -> bool: ...
    def has_time_warp(self) -> bool: ...
    def capacity(self) -> list[int]: ...
    def start_depot(self) -> int: ...
    def end_depot(self) -> int: ...
    def fixed_vehicle_cost(self) -> int: ...
    def load(self) -> list[int]: ...
    def excess_load(self) -> list[int]: ...
    def excess_distance(self) -> int: ...
    def distance(self) -> int: ...
    def distance_cost(self) -> int: ...
    def unit_distance_cost(self) -> int: ...
    def has_distance_cost(self) -> bool: ...
    def duration(self) -> int: ...
    def overtime(self) -> int: ...
    def duration_cost(self) -> int: ...
    def unit_duration_cost(self) -> int: ...
    def unit_overtime_cost(self) -> int: ...
    def has_duration_cost(self) -> bool: ...
    def shift_duration(self) -> int: ...
    def max_duration(self) -> int: ...
    def max_overtime(self) -> int: ...
    def max_distance(self) -> int: ...
    def time_warp(self) -> int: ...
    def profile(self) -> int: ...
    def dist_at(self, idx: int, profile: int = 0) -> int: ...
    def dist_between(self, start: int, end: int, profile: int = 0) -> int: ...
    def dist_before(self, end: int) -> int: ...
    def dist_after(self, start: int) -> int: ...
    def load_at(self, idx: int, dimension: int = 0) -> LoadSegment: ...
    def load_between(
        self, start: int, end: int, dimension: int = 0
    ) -> LoadSegment: ...
    def load_before(self, end: int, dimension: int = 0) -> LoadSegment: ...
    def load_after(self, start: int, dimension: int = 0) -> LoadSegment: ...
    def duration_at(self, idx: int, profile: int = 0) -> DurationSegment: ...
    def duration_between(
        self, start: int, end: int, profile: int = 0
    ) -> DurationSegment: ...
    def duration_before(self, end: int) -> DurationSegment: ...
    def duration_after(self, start: int) -> DurationSegment: ...
    def append(self, node: Node) -> None: ...
    def clear(self) -> None: ...
    def insert(self, idx: int, node: Node) -> None: ...
    @staticmethod
    def swap(first: Node, second: Node) -> None: ...
    def update(self) -> None: ...

class Node:
    def __init__(self, loc: int) -> None: ...
    @property
    def client(self) -> int: ...
    @property
    def idx(self) -> int: ...
    @property
    def trip(self) -> int: ...
    @property
    def route(self) -> Route | None: ...
    def is_depot(self) -> bool: ...
    def is_start_depot(self) -> bool: ...
    def is_end_depot(self) -> bool: ...
    def is_reload_depot(self) -> bool: ...

def insert_cost(
    U: Node, V: Node, data: ProblemData, cost_evaluator: CostEvaluator
) -> int: ...
def inplace_cost(
    U: Node, V: Node, data: ProblemData, cost_evaluator: CostEvaluator
) -> int: ...
def remove_cost(
    U: Node, data: ProblemData, cost_evaluator: CostEvaluator
) -> int: ...
