import numpy as np
from matplotlib.testing.decorators import image_comparison as img_comp
from numpy.testing import assert_, assert_equal, assert_raises

from pyvrp import (
    CostEvaluator,
    Depot,
    Population,
    PopulationParams,
    ProblemData,
    RandomNumberGenerator,
    Result,
    Route,
    Solution,
    Statistics,
    Trip,
    VehicleType,
    plotting,
)
from pyvrp.diversity import broken_pairs_distance
from tests.helpers import read, read_solution

IMG_KWARGS = dict(remove_text=True, tol=8, extensions=["png"], style="mpl20")


@img_comp(["plot_solution", "plot_solution_with_customers"], **IMG_KWARGS)
def test_plot_solution():
    """
    Compares plots generated by ``plot_solution``.
    """
    data = read("data/RC208.vrp", round_func="trunc")
    sol = read_solution("data/RC208.sol", data)

    plotting.plot_solution(sol, data)
    plotting.plot_solution(sol, data, plot_clients=True)


@img_comp(["plot_solution_multiple_depots"], **IMG_KWARGS)
def test_plot_solution_multiple_depots():
    """
    Tests that ``plot_solution`` correctly displays solutions with multiple
    depots (e.g., depots are plotted and lines to/from depots are correctly
    drawn).
    """
    data = read("data/OkSmallMultipleDepots.txt", round_func="trunc")
    routes = [
        Route(data, [2, 3], vehicle_type=0),
        Route(data, [4], vehicle_type=1),
    ]

    plotting.plot_solution(Solution(data, routes), data)


@img_comp(["plot_solution_multiple_trips"], **IMG_KWARGS)
def test_plot_solution_multiple_trips(ok_small_multiple_trips):
    """
    Tests that plot_solution() correctly displays the reload depot visit that
    separates multiple trips.
    """
    trip1 = Trip(ok_small_multiple_trips, [1, 3], 0)
    trip2 = Trip(ok_small_multiple_trips, [2, 4], 0)
    route = Route(ok_small_multiple_trips, [trip1, trip2], 0)
    sol = Solution(ok_small_multiple_trips, [route])

    plotting.plot_solution(sol, ok_small_multiple_trips)


@img_comp(["plot_solution_optional_clients"], **IMG_KWARGS)
def test_plot_solution_optional_clients(ok_small_prizes):
    """
    Tests that plot_solution() correctly displays unvisited locations when the
    instance contains optional clients and ``plot_clients`` is True.
    """
    routes = [
        Route(ok_small_prizes, [2, 3], vehicle_type=0),
        Route(ok_small_prizes, [1], vehicle_type=0),
    ]
    plotting.plot_solution(
        Solution(ok_small_prizes, routes),
        ok_small_prizes,
        plot_clients=True,
    )


@img_comp(["plot_result"], **IMG_KWARGS)
def test_plot_result():
    """
    Compares plots generated by ``plot_result``.
    """
    num_iterations = 100

    data = read("data/RC208.vrp", round_func="trunc")
    bks = read_solution("data/RC208.sol", data)
    cost_evaluator = CostEvaluator([20], 6, 0)
    rng = RandomNumberGenerator(seed=42)

    params = PopulationParams()
    pop = Population(broken_pairs_distance, params=params)
    for _ in range(params.min_pop_size):
        pop.add(Solution.make_random(data, rng), cost_evaluator)

    stats = Statistics()

    for i in range(num_iterations):
        if i == num_iterations // 2:
            # Make sure we insert a feasible solution
            sol = bks
        else:
            sol = Solution.make_random(data, rng)

        pop.add(sol, cost_evaluator)
        stats.collect_from(pop, cost_evaluator)

        # Hacky to produce deterministic result
        stats.runtimes[-1] = i % 3

    res = Result(bks, stats, num_iterations, 0.0)
    plotting.plot_result(res, data)


@img_comp(["plot_instance"], **IMG_KWARGS)
def test_plot_instance():
    """
    Compares plots generated by ``plot_instance``.
    """
    data = read("data/RC208.vrp", round_func="trunc")
    plotting.plot_instance(data)


@img_comp(["plot_instance_multiple_depots"], **IMG_KWARGS)
def test_plot_instance_multiple_depots():
    """
    Tests that ``plot_instance`` correctly displays instances with multiple
    depots.
    """
    data = read("data/OkSmallMultipleDepots.txt", round_func="trunc")
    plotting.plot_instance(data)


@img_comp(["plot_route_schedule"], **IMG_KWARGS)
def test_plot_route_schedule():
    """
    Compares plots generated by ``plot_route_schedule``.
    """
    data = read("data/RC208.vrp", round_func="trunc")
    sol = read_solution("data/RC208.sol", data)
    plotting.plot_route_schedule(data, sol.routes()[0])


def test_plot_demands_raises_for_out_of_bounds_load_dimension():
    """
    Tests that calling ``plot_demands`` on an instance with no load data at all
    raises a ValueError.
    """
    data = ProblemData(
        clients=[],
        depots=[Depot(x=0, y=0)],
        vehicle_types=[VehicleType()],
        distance_matrices=[np.array([[0]])],
        duration_matrices=[np.array([[0]])],
    )

    assert_equal(data.num_load_dimensions, 0)

    with assert_raises(ValueError):
        plotting.plot_demands(data)


def test_plots_do_not_raise_when_there_are_no_feasible_sols(ok_small, recwarn):
    """
    Tests the small bug identified in #724 is fixed. The issue occurred that we
    used to set an axis limit that could be NaN when no feasible solution has
    yet been found.
    """
    sol = Solution(ok_small, [[1, 2, 3, 4]])
    assert_(not sol.is_feasible())

    cost_eval = CostEvaluator([1], 1, 1)

    pop = Population(broken_pairs_distance)
    pop.add(sol, cost_eval)

    stats = Statistics()
    stats.collect_from(pop, cost_eval)

    res = Result(sol, stats, 1, 0.0)
    assert_(not res.is_feasible())

    # This used to either warn about NaN values, or raise because of NaNs.
    plotting.plot_objectives(res)
    plotting.plot_result(res, ok_small)
    assert_equal(len(recwarn), 0)
